<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>A Linguistic Integration Approach for Java and Prolog</title>

	<link rel="stylesheet" href="/styles/publication/sc.tutorial.css" />
	<link rel="stylesheet" href="/styles/publication/sc.tooglejs.css" />

	<script type="text/javascript" src="/js/jquery.min.js" charset="utf-8"></script>
	<script type="text/javascript" src="/js/ace-builds/src-noconflict/ace.js" charset="utf-8"></script>
    <script type="text/javascript" src="/js/publication/jquery.tableofcontents.min.js" charset="utf-8"></script>
	<script type="text/javascript" src="/js/publication/jquery.sc.publication.js" charset="utf-8"></script>
    
    <script type="text/javascript">//<![CDATA[
  (function ($) {
    $(document).ready(function(){
		
      $('#table_of_content_entries').tableOfContents('#content', {startLevel:2, depth: 3});
      $.prettifyCodeSnippets("eclipse");
      //$.prettifyCodeSnippets("solarized_light");
      $.configureFootnotes();

    })

  })(jQuery);


//]]></script>



<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-47515052-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</head>




<body>


<div>

  

  <div style="text-align: center">

	<div><h1 style="margin: 0.4em 0 0.2em 0;">LogicObjects: Enabling the Automatic Integration of Hybrid Java-Prolog Entities</h1></div>
	<!-- 
    <div><h1 style="margin: 0.4em 0 0.2em 0;">LogicObjects: Towards the Automatic Integration of Hybrid Java-Prolog Entities</h1></div>
	-->
	<!-- 
    <div><h1 style="margin: 0.4em 0 0.2em 0;">An Automatic Integration Approach for Java and Prolog <br/> based on Inter-Language Conversions</h1></div>
	-->
    <div>
      Sergio Castro <sup> <a rel="footnote" href="#fn:ucl">1</a> </sup>, 
      Kim Mens <sup> <a rel="footnote" href="#fn:ucl">1</a> </sup> and 
      Paulo Moura <sup> <a rel="footnote" href="#fn:inescporto">2</a> </sup>
    </div>

    <div id="affiliations">

      <div id="fn:ucl">
	    (1)
  	    <a title="Université catholique de Louvain" href="http://www.uclouvain.be/">Université catholique de Louvain</a>,
	    <a title="Institute of Information and Communication Technologies, Electronics and Applied Mathematics" href="http://www.uclouvain.be/icteam/">ICTEAM</a>,
	    <a title="Computing Science Engineering Department" href="http://www.uclouvain.be/ingi/">INGI</a>.
      </div>
  
      <div id="fn:inescporto">
  	    (2)
  	    <a title="Center for Research in Advanced Computing Systems" href="http://www.inescporto.pt/">Center for Research in Advanced Computing Systems, INESC-TEC</a>.
      </div>

    </div> <!-- end of affiliations -->

  </div>

</div>
	
	







<div id="table_of_content">
  <strong>Contents</strong>
  <ol id="table_of_content_entries"></ol>
</div>












<div id="content">

  <h2>Introduction</h2> 

  <p>
  Logic languages are convenient for reasoning over problems of declarative nature, such as expert and planning systems 
  <sup> <a rel="footnote" href="#fn:rus95">1</a> </sup> <sup> <a rel="footnote" href="#fn:Sterling:1994:APA:175753">2</a> </sup>.
  However, it is often difficult to develop real-life applications with only a logic language
  <sup> <a rel="footnote" href="#fn:Cale01">3</a> </sup> <sup> <a rel="footnote" href="#fn:2014-jelia-calejo">4</a> </sup> <sup> <a rel="footnote" href="#fn:conf/lpe/WielemakerA02">5</a> </sup>.
  On the other hand, object-oriented languages have demonstrated their usefulness for modelling a wide range of concepts (e.g., user interfaces) found in many business scenarios 
  <sup> <a rel="footnote" href="#fn:Meyer:1988ys">6</a> </sup>.
  The availability of continuously growing software ecosystems around modern object-oriented languages, including advanced IDEs and rich sets of libraries, has significantly contributed to their success.
  </p>

  <p>
  Non-trivial applications can profit from implementing their components, or distinct routines of the same entity, in the language that is most appropriate for expressing them
  <sup> <a rel="footnote" href="#fn:Cale01">3</a> </sup> 
  <sup> <a rel="footnote" href="#fn:2014-jelia-calejo">4</a> </sup> 
  <sup> <a rel="footnote" href="#fn:Mernik:2005:DDL:1118890.1118892">7</a> </sup>
  <sup> <a rel="footnote" href="#fn:DHondt2004">8</a> </sup>.



  However, the integration of programs written in different languages is not trivial when such languages belong to different paradigms
  <sup> <a rel="footnote" href="#fn:Omicini:1994fk">9</a> </sup>
  <sup> <a rel="footnote" href="#fn:Brichau02towardslinguistic">10</a> </sup> 
  <sup> <a rel="footnote" href="#fn:Gybels2003">11</a> </sup>.
  </p>

  <p>
  Although numerous approaches allow to integrate Java and Prolog programs, few of them make an emphasis on the transparency and automation regarding the integration concern.
  We describe an approach based on the notion of automatic inter-language conversions that tackles this problem.
  </p>
  
  <!--
  <p>
  In the first part of this article we introduce JPC, a Java library for accomplishing bi-directional conversions between Java objects and Prolog terms.
  In the second part we introduce the LogicObjects framework, which facilitates the creation of hybrid systems 
  </p>
  -->

  <h2>Preparing the Ground: Inter-Language Conversions with JPC</h2> 

  <p>
  At the core of our approach lies an extensible and fine-grained mechanism for mapping between artefacts in the Prolog and Java wold.
  A concrete implementation is provided by means of the <a href="http://java-prolog-connectivity.github.com/" title="The JPC library">JPC</a> (Java-Prolog Connectivity) library.
  </p>
  
  <p>
  JPC's design has been inspired by a well-known library for accomplishing context-dependent conversions between Java and <a href="http://json.org/" title="JSON">JSON</a> artefacts: <a href="https://code.google.com/p/google-gson/" title="Google's Gson">Google's Gson</a> library.
  The goal of Gson is to provide an intuitive, minimalistic interface for facilitating the specification and execution of Java-JSON bidirectional conversions.
  As part of our design philosohpy we extrapoleted several design goals of Gson to our domain (i.e., Java-Prolog conversions). Amongst others:
  </p>


  <div class="divList">
  <ul>
	<li>Allows arbitrary objects to be converted to and from Prolog terms. </li>
	<li>Works with pre-existing objects that cannot or should not be modified (e.g., no sources available). </li>
	<li>Includes a considerable catalog of pre-defined bi-directional converters.</li>
	<li>Allows to extend the default conversion strategy by means of custom converters.</li>
	<li>Conversion strategies are encapsulated as reified conversion contexts.</li>
	<li>Supports objects with deep hierarchies that may contain generic classes.</li>
	<li>Type-guided conversions. A Prolog list may be converted to a Java Array, List or Map, according to the expected conversion type, if any.</li>
  </ul>
  </div>



  <h3>The Conversion Context</h3>

  A conversion context is a scoped bidirectional conversion strategy reified by means of the <a href="/javadocs/org/jpc/Jpc.html" title="Jpc class"><code>Jpc</code></a> class.
  New conversion contexts can easily be created by means of a <a href="/javadocs/org/jpc/JpcBuilder.html" title="JpcBuilder class"><code>context builder</code></a>.
  The insantiation of a default conversion context (i.e., a context including only pre-defined conversions) is shown in the code snippet below:

<div class="codeEditor"><pre data-editor="java" data-show-gutter="true">
JpcBuilder builder = JpcBuilder.create(); // a default conversion context builder
Jpc jpc = builder.build(); // a default conversion context</pre></div>

  
  <h3>Pre-Defined Conversions</h3> 

  <p>
  Once a conversion context has been instantiated, it can be employed to convert between Java and Prolog artefacts.
  By default, a conversion context can accomplish common conversions (e.g., conversions between primitives) without further configuration.
  Some of these pre-defined conversions are shown below:
  </p>

<div class="codeEditor"><pre data-editor="java" data-show-gutter="true">
Jpc jpc = JpcBuilder.create().build(); // a default conversion context

//Java to Prolog
jpc.toTerm(true);                  // ==> new Atom("true")
jpc.toTerm("1");                   // ==> new Atom("1")
jpc.toTerm(1);                     // ==> new IntegerTerm(1)
jpc.toTerm(1D);                    // ==> new FloatTerm(1)

//Prolog to Java
jpc.fromTerm(new Atom("true"));    // ==> true
jpc.fromTerm(new Atom("1"));       // ==> "1"
jpc.fromTerm(new IntegerTerm(1));  // ==> 1L
jpc.fromTerm(new FloatTerm(1));    // ==> 1D</pre></div>


  <h3>Type-Guided Conversions</h3> 

  <p>
  Examples of type guided conversions are shown below:
  </p>
  
<div class="codeEditor"><pre data-editor="java" data-show-gutter="true">
Term listTerm = listTerm(new Atom("1"), new Atom("2")); //Prolog list -> ['1', '2']
List<?> list = jpc.fromTerm(listTerm, List.class); //list of strings
String[] array = jpc.fromTerm(listTerm, new String[]{}.getClass()); //array of strings
Type type = new TypeToken&lt;List&lt;Integer&gt;&gt;(){}.getType(); //reification of the List&lt;Integer&gt; type
list = jpc.fromTerm(listTerm, type); //list of integers</pre></div>


  <h3>Custom Conversions</h3> 

  <p>
  A conversion context can be extended with custom converters.
  A converter is just a class implementing the <code>FromTermConverter</code> and/or <code>ToTermConverter</code> interfaces.
  When registered into a conversion context, a converter adds to the pre-defined conversions a new mapping of artefacts.
  As an example, consider a converter that knows how to convert a Prolog term to an instance of the <code>Person</code> class:
  </p>

<div class="codeEditor"><pre data-editor="java" data-show-gutter="true">
public class PersonConverter implements FromTermConverter&lt;Compound, Person&gt; {

	@Override public Person fromTerm(Compound term, Type type, Jpc context) {
		String personName = ((Atom)term.arg(1)).getName();
		return new Person(personName);
	}
	
}</pre></div>

  <p>
  The following code snippet illustrates how a custom conversion context extended with the <code>PersonConverter</code> can be employed to facilitate the interpretation of a query result as a Java object with a minimum anount of code:
  </p>


<div class="codeEditor"><pre data-editor="java" data-show-gutter="true">
JpcBuilder builder = JpcBuilder.create().registerConverter(new PersonConverter(), 
														   new Functor("person"), 1).asTerm()); // the converter is associated with terms of the form: person(_)
Jpc jpc = builder.build(); //custom conversion context
Person person = engine.createQuery("cool_person(P)", jpc).&lt;Person&gt;selectObject("P").oneSolutionOrThrow(); //the term bound to P is automatically converted to an instance of class Person </pre></div>

  Note that at the moment of registering the converter, it is associated with a compound term with functor <code>person/1</code> (line 2). Therefore, the converter is applicable only to terms having such a functor.




  <h2>Automatic Integration of Hybrid Applications with LogicObjects</h2> 

  <p>
  The inter-language conversion framework provided by JPC is a convenient building block for facilitating the implementation of more advanced integration libraries.
  LogicObjects is an integration framework for Java and Prolog built on top of it.
  It allows to define hybrid entities which partial implementations in Java and Prolog.
  Although to a certain extent LogicObjects is compatible with plain Prolog, to get the best of it, it is recommended to install on the Prolog side Logtalk, an object-oriented layer for Prolog.
  </p>

  <p>
  Figure one shows the definition of a <code>Person</code> entity.
  This entity has a dual expression. In the Java world, it takes the form of an instance of the <code>Person</code> class. On the Prolog world, it is reified as the Logtalk parametric object <code>person/1</code>.
  In this example, the implementation is scattered in the two worlds (the method <code>experience()</code> is defined in Java and the predicate <code>salary/1</code> in Prolog). 
  However, it is also possible to create entities that are completely defined either in Java or Prolog, but still accessible from the foreign language.
  </p>


  <div class="divImg">
    <img src="img/examples/interaction_person.svg" alt="The Person entity." style="padding-bottom:0.5em;" height="250" />
    <div id="imglabel:interaction_person" >Fig 1. - A dual representation of a Person entity.</div>
  </div>

  <p>
  In the rest of this section we review the integration from both languages perspective.
  </p>



  <h3>Integration from the Java Perspective</h3> 
 
   <p>
   The following code snippet shows the Java side of the implementation of the <code>Person</code> entity.
   Abstract methods correspond to routines implemented in Prolog/Logtalk.
   </p>
 
 <div class="codeEditor"><pre data-editor="java" data-show-gutter="true">
 @LObject(name="person", args={"name"})
 abstract class Person {
 	private final String name;
	
 	public Person(String name) {this.name = name;}

 	@LMethod(args = {"LSolution"})
 	public abstract int salary();
	
 	public int experience() {
 		...
 	}

 }</pre></div>
 
  <p>
  The <code>@LObject</code> annotation provides mapping information to LogicObjects.
  The <code>name</code> attribute indicates than an instance of the <code>Person</code> class is reified as a compound with name <code>person</code>.
  The <code>args</code> attribute signals than the argument of such compound is the term representation of the instance variable <code>name</code>.
  </p>

  <p>
  The <code>@LMethod</code> annotation provides mapping information regarding a specific routine.
  In this case, the <code>salary()</code> Java method is mapped to a predicate having the same name.
  As arguments, it will have the unbound logic variable <code>LSolution</code>.
  Therefore, an invocation of the <code>salary()</code> method on a person with name <code>"mary"</code> will be interpreted as querying the Prolog goal <code>person(mary)::salary(LSolution)</code>.
  </p>
  
  
  
  <p>
  LogicObjects provide several heuristics for determining the return value in Java of a routine implemented on the Prolog side.
  One of them consists on inspecting the names of the unbound logic variables. In case it encounters an occurrence of a variable named <code>LSolution</code>, it will consider as the return value of the method the conversion to a Java object of the term bound to such a variable. 
  Note that by default a query is interpreted as deterministic. Hence, only its first solution is considered. However, this can be customised by means of other Java annotations (e.g., to compose all the solutions in a container such as an instance of <code>java.util.List</code>).
  </p>
  
  <p>
  An instance of the <code>Person</code> class can be obtained by means of the static method <code>LogicObjects.newLogicObject</code>, as shown in the following code snippet:
  </p>


 <div class="codeEditor"><pre data-editor="java" data-show-gutter="true">
import static org.logicobjects.newLogicObject;
...

Person person = newLogicObject(Person.class, "mary");
System.out.println("Salary: " + person.salary());</pre></div>



  <h3>Integration from the Prolog Perspective</h3> 

  <p>
  The logic counterpart of the <code>Person</code> class is the Logtalk parametric object <code>person/1</code> defined as in the following code snippet:
  </p>
  
<div class="codeEditor"><pre data-editor="prolog" data-show-gutter="true">
:- object(person(_Name) imports jobject).

	:- public(salary/1).
	salary(S) :- ...

:- end_object.</pre></div>

  <p>
  Any Logtalk object importing the <code>jobject</code> category, will delegate to the Java side any message not understood. 
  For example, a Logtalk call <code>person(mary)::experience</code>, will be interpreted in Java as <code>new Person("mary").experience</code>.
  If the programmer 
  </p>

  <p>
  If the return value of a Java method is required on the Prolog side, distinct mechanisms are available, all of them relying on the notion of a <emph>return specifier</emph>.
  The following Logtalk method invocations are equivalent:
  </p>
  
<div class="codeEditor"><pre data-editor="prolog" data-show-gutter="true">
person(mary)::experience(return(term(E))). %return value specified as an argument of the method.
jobject(person(mary), return(term(E)))::experience. %return value specified as an argument of the jobject/2 Logtalk object.
person(mary)::experience return(term(E)). %return value specified by means of the return operator.</pre></div>
  
  <p>
  A return specifier assigns a semantics to a Java method returned value in Prolog. They consist of a compound term that wraps as one of its descendants a term representing a Java object.
  Some examples follow:
</p>
  
  
  <div class="divList">
  <ul>
	<li><code>term(R)</code>: <code>R</code> is the default conversion to a term of the returned object.</li>
	<li><code>jserialized(R)</code>: <code>R</code> is a term representation of the serialisation of the returned object.</li>
	<li><code>jref(R)</code>: <code>R</code> is an opaque term representation of a Java reference. The reference remains valid as long as the term exists somewhere in the Prolog database.</li>
	<li><code>weak(jref(R))</code>: <code>R</code> is an opaque term representation of a Java reference. The reference remains valid as long as the reference is not garbage-collected on the Java world.</li>
	<li><code>strong(jref(R))</code>: <code>R</code> is an opaque term representation of a Java reference. The reference remains valid as long as the reference representation is not explicitly forgotten.</li>
  </ul>
  </div>
  
  
  
  
  <h2>Compatibility</h2> 

  <p>
  JPC and LogicObjects are currently compatible with SWI, YAP and XSB Prolog by means of drivers developed on top of the JPL, PDT Connector and InterProlog libraries.
  </p>


  <h2>Conclusions</h2> 

  <p>
  This paper provides a short overview over the JPC and LogicObjects libraries. 
  Further information can be found in the online documentation.
  </p>




</div> <!-- end of content -->





<div id="footnotes">
  <hr />
  
  <h3>Footnotes</h3>
  
  <ol>
  
  <li id="fn:rus95">
  	Artificial Intelligence, A Modern Approach. Russel, S. and Norvig, P. Prentice Hall. 1995.
  </li>
  
  <li id="fn:Sterling:1994:APA:175753">
  	The Art of Prolog (2nd ed.): Advanced Programming Techniques. Sterling, L. and Shapiro, E. MIT Press. Cambridge, MA, USA. 1994.
  </li>
  
  <li id="fn:Cale01">
  	Interprolog: A Declarative Java-Prolog Interface. Calejo, M. EPIA. Springer. 2001.
  </li>
  
  <li id="fn:2014-jelia-calejo">
  	InterProlog: Towards a Declarative Embedding of Logic Programming in Java. Calejo, M. In proceedings of Logics in Artificial Intelligence, 9th European Conference, JELIA. V. 3229. Pages 714-717. Lisbon, Portugal. September 27-30, 2004.
  </li>
  
  <li id="fn:conf/lpe/WielemakerA02">
  	An Architecture for Making Object-Oriented Systems Available from Prolog. Wielemaker, J. and Anjewierden, A. Workshop on Logic-based methods in Programming Environments (WLPE). 2002.
  </li>
  
  <li id="fn:Meyer:1988ys">
  	Object-Oriented Software Construction. Meyer, B. Prentice-Hall, Inc. 1988.
  </li>
  
  <li id="fn:Mernik:2005:DDL:1118890.1118892">
  	When and How to Develop Domain-specific Languages. Mernik, M, Heering, J. and Sloane, A. M. ACM Comput. Surv. V. 37, N. 4, Pages 316-344. New York, USA. December 2005.
  </li>
  
  <li id="fn:DHondt2004">
  	Seamless integration of rule-based knowledge and object-oriented functionality with linguistic symbiosis. D'Hondt, M., Gybels, K. and Jonckers, V. Proceedings of the 2004 ACM symposium on Applied computing. New York, USA. 2004.
  </li>
  
  <li id="fn:Omicini:1994fk">
  	Object-oriented computations in logic programming. Omicini, A. and Natali, A. Object-Oriented Programming. Lecture Notes in Computer Science. V. 821, Pages 194-212. 1994.
  </li>

  <li id="fn:Brichau02towardslinguistic">
  	Towards Linguistic Symbiosis of an Object-Oriented and a Logic Programming Language. Brichau, J. Gybels, K and Wuyts, R. In Jörg Striegnitz, Kei Davis, and Yannis Smaragdakis, editors, Proceedings of the Workshop on Multiparadigm Programming with Object-Oriented Languages. 2002.
  </li>
  
  <li id="fn:Gybels2003">
  	SOUL and Smalltalk - Just Married: Evolution of the Interaction Between a Logic and an Object-Oriented Language Towards Symbiosis. Gybels, K. Proceedings of the Workshop on Declarative Programming in the Context of Object-Oriented Languages. 2003.
  </li>
  
  </ol>
  
</div> <!-- end of footnotes -->

    

</body>
</html>
