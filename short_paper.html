<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>A Linguistic Integration Approach for Java and Prolog</title>

	<link rel="stylesheet" href="/styles/publication/sc.tutorial.css" />
	<link rel="stylesheet" href="/styles/publication/sc.tooglejs.css" />

	<script type="text/javascript" src="/js/jquery.min.js" charset="utf-8"></script>
	<script type="text/javascript" src="/js/ace-builds/src-noconflict/ace.js" charset="utf-8"></script>
    <script type="text/javascript" src="/js/publication/jquery.tableofcontents.min.js" charset="utf-8"></script>
	<script type="text/javascript" src="/js/publication/jquery.sc.publication.js" charset="utf-8"></script>
    
    <script type="text/javascript">//<![CDATA[
  (function ($) {
    $(document).ready(function(){
		
      $('#table_of_content_entries').tableOfContents('#content', {startLevel:2, depth: 3});
      $.prettifyCodeSnippets("eclipse");
      //$.prettifyCodeSnippets("solarized_light");
      $.configureFootnotes();

    })

  })(jQuery);


//]]></script>



<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-47515052-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</head>




<body>


<div>

  

  <div style="text-align: center">

    <div><h1 style="margin: 0.4em 0 0.2em 0;">An Integration Approach for Java and Prolog <br/> based on Automatic Inter-Language Conversions</h1></div>
    <div>
      Sergio Castro <sup> <a rel="footnote" href="#fn:ucl">1</a> </sup>, 
      Kim Mens <sup> <a rel="footnote" href="#fn:ucl">1</a> </sup> and 
      Paulo Moura <sup> <a rel="footnote" href="#fn:inescporto">2</a> </sup>
    </div>

    <div id="affiliations">

      <div id="fn:ucl">
	    (1)
  	    <a title="Université catholique de Louvain" href="http://www.uclouvain.be/">Université catholique de Louvain</a>,
	    <a title="Institute of Information and Communication Technologies, Electronics and Applied Mathematics" href="http://www.uclouvain.be/icteam/">ICTEAM</a>,
	    <a title="Computing Science Engineering Department" href="http://www.uclouvain.be/ingi/">INGI</a>.
      </div>
  
      <div id="fn:inescporto">
  	    (2)
  	    <a title="Center for Research in Advanced Computing Systems" href="http://www.inescporto.pt/">Center for Research in Advanced Computing Systems, INESC-TEC</a>.
      </div>

    </div> <!-- end of affiliations -->

  </div>

</div>
	
	







<div id="table_of_content">
  <strong>Contents</strong>
  <ol id="table_of_content_entries"></ol>
</div>













<div id="content">

<h2>Introduction</h2> 

<p>
Although numerous approaches allow to integrate Java and Prolog programs, few of them make an emphasis on the transparency and automation regarding the integration concern.
We describe an approach based on the notion of automatic inter-language conversions that tackles this problem.
</p>


<h2>Inter-Language Conversions with JPC</h2> 

<p>
At the core of our approach lies an extensible and fine-grained mechanism for mapping between artefacts in the Prolog and Java wold.
A concrete implementation of it is provided by means of the JPC (Java-Prolog Connectivity) library.
JPC has been inspired by a well-known library for accomplishing context-dependent conversions between Java and JSON artefacts: the Google's Gson library.
As part of our design philosohpy we include several design goals of Gson extra-polated to our domain. Among others:
</p>


<div class="divList">
<ul>
	<li>Allows arbitrary objects to be converted to and from Prolog terms. </li>
	<li>Works with pre-existing objects that cannot or should not be modified (e.g., no sources available). </li>
	<li>Includes a considerable catalog of pre-defined bi-directional converters.</li>
	<li>Allows to extend the default conversion strategy by means of custom converters.</li>
	<li>A conversion strategy is encapsulated as a reified conversion context.</li>
	<li>Supports objects with deep hierarchies that may contain generic classes.</li>
	<li>Type-guided conversions. A Prolog list may be converted to a Java Array, List or Map, according to the expected conversion type, if any.</li>
</ul>
</div>

<h3>Pre-Defined Conversions</h3> 

<p>
Example of predefined conversions are shown below:
</p>

<div class="codeEditor"><pre data-editor="java" data-show-gutter="true">
Jpc jpc = JpcBuilder.create().build(); // a default conversion context

//Java to Prolog
jpc.toTerm(true);                  // ==> new Atom("true")
jpc.toTerm("1");                   // ==> new Atom("1")
jpc.toTerm(1);                     // ==> new IntegerTerm(1)
jpc.toTerm(1D);                    // ==> new FloatTerm(1)

//Prolog to Java
jpc.fromTerm(new Atom("true"));    // ==> true
jpc.fromTerm(new Atom("1"));       // ==> "1"
jpc.fromTerm(new IntegerTerm(1));  // ==> 1L
jpc.fromTerm(new FloatTerm(1));    // ==> 1D</pre></div>


<h3>Type-Guided Conversions</h3> 

Examples of type guided conversions are shown below:

<div class="codeEditor"><pre data-editor="java" data-show-gutter="true">
Term listTerm = listTerm(new Atom("1"), new Atom("2")); //Prolog list -> ['1', '2']
List<?> list = jpc.fromTerm(listTerm, List.class); //list of strings
String[] array = jpc.fromTerm(listTerm, new String[]{}.getClass()); //array of strings
Type type = new TypeToken&lt;List&lt;Integer&gt;&gt;(){}.getType(); //reification of the List&lt;Integer&gt; type
list = jpc.fromTerm(listTerm, type); //list of integers</pre></div>


<h3>Custom Conversions</h3> 

<p>
A conversion context can be extended with custom converters.
Consider the simple converter below:
</p>

<div class="codeEditor"><pre data-editor="java" data-show-gutter="true">
public class PersonConverter implements FromTermConverter&lt;Compound, Person&gt; {

	@Override public Person fromTerm(Compound term, Type type, Jpc context) {
		String personName = ((Atom)term.arg(1)).getName();
		return new Person(personName);
	}
	
}</pre></div>

<p>
This converter can be registered into a conversion context.
The conversion context can be then employed to instantiate a query that facilitates the transparent conversion between Prolog terms and Java objects.
</p>


<div class="codeEditor"><pre data-editor="java" data-show-gutter="true">
JpcBuilder builder = JpcBuilder.create().registerConverter(new PersonConverter(), 
														   new Functor("person"), 1).asTerm()); // the converter is associated with terms of the form: person(_)
Jpc jpc = builder.build(); //custom conversion context
Person person = engine.createQuery("cool_person(P)", jpc).&lt;Person&gt;selectObject("P").oneSolutionOrThrow(); //the term bound to P is automatically converted to an instance of class Person </pre></div>



<h2>Automatic Integration with LogicObjects</h2> 

<p>
LogicObjects is an integration framework for Java and Prolog built on top of the JPC library.
It allows to define hybrid entities which partial implementations in Java and Prolog.
Although to a certain extent LogicObjects is compatible with plain Prolog, to get the best of it, it is recommended to install on the Prolog side Logtalk, an object-oriented layer for Prolog.
</p>

<p>
Figure one shows the definition of a <code>Person</code> entity.
This entity has a dual expression. In the Java world, it takes the form of an instance of the <code>Person</code> class. On the Prolog world, it is reified as the Logtalk parametric object <code>person/1</code>.
In this example, the implementation is scattered in the two worlds (the method <code>experience()</code> is defined in Java and the predicate <code>salary/1</code> in Prolog). 
However, it is also possible to create entities that are completely defined either in Java or Prolog, but still accessible from the foreign language.
</p>


<div class="divImg">
  <img src="img/examples/interaction_person.svg" alt="The Person entity." style="padding-bottom:0.5em;" height="220" />
  <div id="imglabel:interaction_person" >Fig 1. - A dual representation of a Person entity.</div>
</div>

<p>
In the rest of this section we review the integration from both language perspectives.
</p>

<div class="codeEditor"><pre data-editor="java" data-show-gutter="true">
@LObject(name="person", args={"name"})
abstract class Person {
	private final String name;
	
	public Person(String name) {this.name = name;}

	@LMethod(args = {"LSolution"})
	public abstract int salary();
	
	public int experience() {
		...
	}

}</pre></div>


<div class="codeEditor"><pre data-editor="prolog" data-show-gutter="true">
:- object(person(_Name) imports jobject).

	:- public(salary/1).
	salary(S) :- ...

:- end_object.</pre></div>




<h3>Integration from the Java Perspective</h3> 
 
 
 

<h3>Integration from the Prolog Perspective</h3> 




<h2>Conclusions</h2> 

<p>
This paper provides a short overview over the JPC and LogicObjects libraries. 
Further information can be found in the online documentation.
</p>




</div> <!-- end of content -->

    

</body>
</html>
