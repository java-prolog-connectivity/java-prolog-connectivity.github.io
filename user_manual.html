<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>JPC User Guide</title>

	<link rel="stylesheet" href="/styles/publication/sc.tutorial.css" />
	<link rel="stylesheet" href="/styles/publication/sc.tooglejs.css" />

	<script type="text/javascript" src="/js/jquery.min.js" charset="utf-8"></script>
	<script type="text/javascript" src="/js/ace-builds/src-noconflict/ace.js" charset="utf-8"></script>
    <script type="text/javascript" src="/js/publication/jquery.tableofcontents.min.js" charset="utf-8"></script>
	<script type="text/javascript" src="/js/publication/jquery.sc.publication.js" charset="utf-8"></script>
    
    <script type="text/javascript">//<![CDATA[
  (function ($) {
    $(document).ready(function(){
		
      $('#table_of_content_entries').tableOfContents('#content', {startLevel:2, depth: 3});
      $.prettifyCodeSnippets("eclipse");
      //$.prettifyCodeSnippets("solarized_light");
      $.configureFootnotes();

    })

  })(jQuery);


//]]></script>



<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-47515052-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</head>




<body>



<h1>JPC User Guide</h1>


<div id="table_of_content">
  <strong>Contents</strong>
  <ol id="table_of_content_entries"></ol>
</div>


<div id="content">

<h2>Introduction</h2> 

<p>
JPC is a Java-Prolog interoperability library providing different levels of abstractions for integrating systems written in these two languages.
This guide presents the different JPC features supporting this integration.
This document assumes a general understanding of the <a href="architecture.html" title="JPC architecture">JPC architecture</a>.
In order to try the examples, please refer to the <a href="installation_guide.html" title="JPC Installation guide">JPC installation guide</a>.
</p>


<h2>Creating Prolog Engines</h2> 

<p>
JPC provides an abstraction of a Prolog engine that can communicate with concrete Prolog engines by means of drivers.
</p>

<h3>Explicit Instantiation</h3> 

<p>
The easiest way to instantiate a Prolog engine is by explicitly referencing a JPC driver.
For example, to instantiate a JPC engine using the <a href="installation_guide.html#pdtDriver" title="PDT-based driver">PDT-based driver</a> we could write:
</p>

<p><pre data-editor="java" data-show-gutter="true">
PrologEngine engine = new PdtConnectorDriver().createPrologEngine();
</pre></p>


<p>
This approach, although straightforward, causes a strong coupling between an application and a concrete driver.
An alternative is presented below.
</p>


<h3>Categorized Prolog Engines</h3> 

<p>
JPC allows a programmer to easily categorize an "engine space" (i.e., the space of all possible Prolog engines) according to some developer-chosen criteria.
This approach, directly inspired on <a href="http://logging.apache.org/log4j/1.2/" title="Apache log4j">Apache log4j</a> (a well-known logging library), allows to decouple a program from concrete engine implementations.
</p>

<p>
Using this technique, engines are organized hierarchically following a naming rule. 
In this named hierarchy, a name <code>"org.jpc"</code> is said to be the ancestor of the name <code>"org.jpc.Jpc"</code>.
An engine categorized by means of a name will be inherited, unless overridden, by any of its name descendants.
This categorization is illustrated by the figure below.
</p>

<div class="divImg">
  <img src="img/jpc/jpc_named_hierarchy.svg" alt="Named categorization for engines." style="padding-bottom:0.5em;" height="233" />
  <div id="imglabel:jpc_named_hierarchy" >Fig 1. - A named categorization for engines.</div>
</div>

<p>
Engine spaces can be defined either programmatically or by means of configuration files.
The latter is the JPC recommended approach.
</p>

<p>
A JPC configuration is a <a href="http://json.org/" title="JSON">JSON</a> object.
One of the attributes of this configuration object is <code>engines</code>, a list of engine configurations.
The following JPC configuration specifies a Logtalk compatible Prolog engine categorized under the name <code>"org.jpc"</code>.
</p>

<p><pre data-editor="json" data-show-gutter="true">
{
	"engines": [
	  {
	    "id": "pdt",
	    "categoryNames": ["org.jpc"],
	    "factory": "org.jpc.engine.pdtconnector.PdtConnectorDriver",
	    "profile": "org.jpc.engine.profile.LogtalkEngineProfile"
	  }
	]
}</pre></p>


<p>
Each engine configuration has the following attributes:
</p>

<ul>
	<li><code>id</code>: The identifier of this engine configuration. This attribute is optional if the <code>categoryNames</code> attribute is specified.</li>
	<li><code>categoryNames</code>: A list of category names to which this engine configuration applies. This attribute is optional if the <code>id</code> attribute is specified.</li>
	<li><code>factory</code>: A <a href="http://en.wikipedia.org/wiki/Factory_pattern" title="Factory pattern">factory</a> of Prolog engines (usually a JPC driver) associated to this engine configuration.</li>
	<li><code>profile</code>: A <a href="http://en.wikipedia.org/wiki/Decorator_pattern" title="Decorator pattern">decorator</a> that may configure the Prolog engine the first time it is instantiated. This attribute is optional.
</ul>

<p>
Although Prolog engines can be categorized by means of any name, the JPC convention is to categorize them according to the fully qualified name of the class or package where they are used.
Therefore, an engine categorized for the <code>org.jpc</code> package will be used in the <code>org.jpc.Jpc</code> class unless overridden (i.e., if another engine has been categorized for the name <code>"org.jpc.Jpc"</code>).
Then, to obtain a Prolog engine in an arbitrary class, you need to write:
</p>

<p><pre data-editor="java" data-show-gutter="true">
EngineConfigurationManager.getDefault().getPrologEngine(getClass().getCanonicalName()); //returns a Prolog engine categorized for this class fully qualified name.
//or just:
EngineConfigurationManager.getDefault().getPrologEngine(getClass());</pre></p>

<p>
Alternatively, a Prolog engine may be instantiated by means of the <code>id</code> of an engine configuration, like: 
</p>

<p><pre data-editor="java" data-show-gutter="true">
EngineConfigurationManager.getDefault().getPrologEngineById("pdt");</pre></p>

<p>
The <code>EngineConfigurationManager.getDefault()</code> method returns a configuration manager instantiated from the default settings file <code>jpc.settings</code>.
Alternatively, a configuration manager can be instantiated from an arbitrary configuration file by means of: 
<code>EngineConfigurationManager.createFromFile(&lt;file_name&gt;)</code>.
</p>



<h2 id="lowLevelAPI">The Querying API</h2> 


<h3 id="lowLevelAPI">The Low-Level Querying API</h3> 

<p>
All the JPC methods that deal explicitly with Prolog terms are part of the low-level API.
</p>


<h3 id="highLevelAPI">The High-Level Querying API</h3> 

This section is based on the London Underground example described <a href="/london_underground.html" title="London underground example">here</a>.


<p>
Methods that abstract from the term representation of arbitrary Java objects are part of the JPC high-level API.
</p>

<h2>Exception Management</h2> 



<h2>Reference Management</h2> 



</div> <!-- end of content -->

    

</body>
</html>
