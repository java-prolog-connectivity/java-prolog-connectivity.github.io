<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>JPC User Guide</title>

	<link rel="stylesheet" href="/styles/publication/sc.tutorial.css" />
	<link rel="stylesheet" href="/styles/publication/sc.tooglejs.css" />

	<script type="text/javascript" src="/js/jquery.min.js" charset="utf-8"></script>
	<script type="text/javascript" src="/js/ace-builds/src-noconflict/ace.js" charset="utf-8"></script>
    <script type="text/javascript" src="/js/publication/jquery.tableofcontents.min.js" charset="utf-8"></script>
	<script type="text/javascript" src="/js/publication/jquery.sc.publication.js" charset="utf-8"></script>
    
    <script type="text/javascript">//<![CDATA[
  (function ($) {
    $(document).ready(function(){
		
      $('#table_of_content_entries').tableOfContents('#content', {startLevel:2, depth: 3});
      $.prettifyCodeSnippets("eclipse");
      //$.prettifyCodeSnippets("solarized_light");
      $.configureFootnotes();

    })

  })(jQuery);


//]]></script>



<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-47515052-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</head>




<body>



<h1>JPC User Guide</h1>


<div id="table_of_content">
  <strong>Contents</strong>
  <ol id="table_of_content_entries"></ol>
</div>


<div id="content">

<h2>Introduction</h2> 

<p>
JPC is a Java-Prolog interoperability library providing different levels of abstractions for integrating systems written in these two languages.
This guide presents the different JPC features supporting this integration.
This document assumes a general understanding of the <a href="architecture.html" title="JPC architecture">JPC architecture</a>.
In order to try the examples, please refer to the <a href="installation_guide.html" title="JPC Installation guide">JPC installation guide</a>.
</p>


<h2>Creating Prolog Engines</h2> 

<p>
JPC provides an abstraction of a Prolog engine that can communicate with concrete Prolog engines by means of drivers.
</p>

<h3>Explicit Instantiation</h3> 

<p>
The easiest way to instantiate a Prolog engine is by explicitly referencing a JPC driver.
For example, to instantiate a JPC engine using the <a href="installation_guide.html#pdtDriver" title="PDT-based driver">PDT-based driver</a> we could write:
</p>

<p><pre data-editor="java" data-show-gutter="true">
PrologEngine engine = new PdtConnectorDriver().createPrologEngine();
</pre></p>


<p>
This approach, although straightforward, causes a strong coupling between an application and a concrete driver.
An alternative is presented below.
</p>


<h3>Categorized Prolog Engines</h3> 

<p>
JPC allows to easily categorize an "engine space" (i.e., the space of all possible Prolog engines) according to some developer-chosen criteria.
This approach, directly inspired on <a href="http://logging.apache.org/log4j/1.2/" title="Apache log4j">Apache log4j</a> (a well-known logging library), allows to decouple a program from concrete engine implementations.
</p>

<p>
Using this technique, engines are organized hierarchically following a naming rule. 
In this named hierarchy, a name <code>"org.jpc"</code> is said to be the ancestor of the name <code>"org.jpc.Jpc"</code>.
An engine categorized by means of a name will be inherited, unless overridden, by any of its name descendants.
This categorization is illustrated by the figure below.
</p>

<div class="divImg">
  <img src="img/jpc/jpc_named_hierarchy.svg" alt="Named categorization for engines." style="padding-bottom:0.5em;" height="233" />
  <div id="imglabel:jpc_named_hierarchy" >Fig 1. - A named categorization for engines.</div>
</div>

<p>
An engine space can be defined either programmatically or by means of a configuration file.
The latter is the JPC recommended approach.
</p>

<p>
A JPC configuration is a <a href="http://json.org/" title="JSON">JSON</a> object.
One of the attributes of this configuration object is <code>engines</code>, a list of engine configurations.
The following JPC configuration specifies a Logtalk compatible Prolog engine categorized under the name <code>"org.jpc"</code>.
</p>

<p><pre data-editor="json" data-show-gutter="true">
{
	"engines": [
	  {
	    "id": "pdt",
	    "categoryNames": ["org.jpc"],
	    "factory": "org.jpc.engine.pdtconnector.PdtConnectorDriver",
	    "profile": "org.jpc.engine.profile.LogtalkEngineProfile"
	  }
	]
}</pre></p>


<p>
Each engine configuration has the following attributes:
</p>

<ul>
	<li><code>id</code>: The identifier of this engine configuration. This attribute is optional if the <code>categoryNames</code> attribute is specified.</li>
	<li><code>categoryNames</code>: A list of category names to which this engine configuration applies. This attribute is optional if the <code>id</code> attribute is specified.</li>
	<li><code>factory</code>: A <a href="http://en.wikipedia.org/wiki/Factory_pattern" title="Factory pattern">factory</a> of Prolog engines (usually a JPC driver) associated to this engine configuration.</li>
	<li><code>profile</code>: A <a href="http://en.wikipedia.org/wiki/Decorator_pattern" title="Decorator pattern">decorator</a> that may configure the Prolog engine the first time it is instantiated. This attribute is optional.
</ul>

<p>
Although Prolog engines can be categorized by means of any name, the JPC convention is to categorize them according to the fully qualified name of the class or package where they are used.
Therefore, an engine categorized for the <code>org.jpc</code> package will be used in the <code>org.jpc.Jpc</code> class unless overridden (i.e., if another engine has been categorized for the name <code>"org.jpc.Jpc"</code>).
Then, to obtain a Prolog engine in an arbitrary class, you need to write:
</p>

<p><pre data-editor="java" data-show-gutter="true">
EngineConfigurationManager.getDefault().getPrologEngine(getClass().getCanonicalName()); //returns a Prolog engine categorized for this class fully qualified name.
//or just:
EngineConfigurationManager.getDefault().getPrologEngine(getClass());</pre></p>

<p>
Alternatively, a Prolog engine may be instantiated by means of the <code>id</code> of an engine configuration, like: 
</p>

<p><pre data-editor="java" data-show-gutter="true">
EngineConfigurationManager.getDefault().getPrologEngineById("pdt");</pre></p>

<p>
The <code>EngineConfigurationManager.getDefault()</code> method returns a configuration manager instantiated from the default settings file <code>jpc.settings</code>.
Alternatively, a configuration manager can be instantiated from an arbitrary configuration file by means of: 
<code>EngineConfigurationManager.createFromFile(&lt;file_name&gt;)</code>.
</p>





<h2 id="conversionAPI">The Conversion API</h2> 

<h3 id="conversionOverview">Conversion API Overview</h3> 

<p>
JPC provides an API for converting between Java Objects into their Prolog term representation and back.
This conversion API can work with any kind of objects, including those whose source code is not available.
It provides constructs for:
</p>

<ul>
	<li>Defining (bidirectional) Java-Prolog conversion functions (converters).</li>
	<li>Inferring the best target type of a conversion operation (type solvers).</li>
	<li>(Optionally) instantiating conversion target types (factories).</li>
</ul>

<p>
Several examples in this section and in the rest of this tutorial refer to our <a href="/london_underground.html" title="London underground example">London underground case study</a>.
</p>


<h3 id="conversionContext">The JPC Context</h3> 

<p>
Our primary library class is a conversion context, modelled by the <a href="/javadocs/org/jpc/Jpc.html" title="Jpc class"><code>Jpc</code></a> class.
This context encapsulates a bidirectional conversion strategy for a set of Java objects and Prolog terms.
A converter is configured in term of converters, type solvers, factories and other conversion artefacts.
Figure 2 illustrates its main components.
</p>

<div class="divImg">
  <img src="img/jpc/jpc_context.svg" alt="The JPC Context." style="padding-bottom:0.5em;" height="180" />
  <div id="imglabel:jpc_context" >Fig 2. - The JPC Context.</div>
</div>

<p>
In order to facilitate the configuration of a <a href="/javadocs/org/jpc/Jpc.html" title="Jpc class"><code>Jpc</code></a> instance, there is also a <a href="/javadocs/org/jpc/JpcBuilder.html" title="JpcBuilder class"><code>JpcBuilder</code></a> class with a straightforward fluent API for configuring its properties. This configuration involves the registration of different conversion artefacts (e.g., <a href="#implementingConverters" title="Converters">converters</a>, <a href="#implementingTypeSolvers" title="Type solvers">type solvers</a> and <a href="#implementingFactories" title="Factories">factories</a>).
The example below shows how to configure a builder to create a <a href="/javadocs/org/jpc/Jpc.html" title="Jpc class"><code>Jpc</code></a> context that knows how to convert objects from the <a href="/london_underground.html" title="London underground example"><code>London underground case study</code></a>.
</p>



<p><pre data-editor="java" data-show-gutter="true">
public static final Jpc jpc = JpcBuilder.create()
    .register(new MetroConverter())
    .register(new LineConverter())
    .register(new StationConverter()).build();</pre></p>




<h3 id="implementingConverters">Implementing Converters</h3> 

<p>
JPC provides two interfaces for defining conversions from Java to Prolog (<code>ToTermConverter</code>) and vice versa (<code>FromTermConverter</code>).
The <a href="jpc.examples/javadocs/org/jpc/examples/metro/model/hlapi/converters/StationConverter.html" title="StationConverter class"><code>StationConverter</code></a> class in the code below implements both interfaces. It implements a method defining the conversion of <code>Station</code> instances to (lines 6--8) and from (lines 10--13) a Prolog compound term.
</p>





<p><pre data-editor="java" data-show-gutter="true">
public class StationConverter implements 
		ToTermConverter&lt;Station, Compound&gt;, 
		FromTermConverter&lt;Compound, Station&gt;  {
	public static final String STATION_FUNCTOR = &quot;station&quot;;

	@Override public Compound toTerm(Station station, Class&lt;Compound&gt; termClass, Jpc context) {
		return new Compound(STATION_FUNCTOR, asList(new Atom(station.getName())));
	}

	@Override public Station fromTerm(Compound term, Type type, Jpc context) {
		String stationName = ((Atom)term.arg(1)).getName();
		return new StationJpc(stationName);
	}
}</pre></p>




<h3 id="implementingTypeSolvers">Implementing Type Solvers</h3> 

<p>
When no type information is provided in a conversion, JPC attempts to infer the best target type based on the actual source object to convert.
For example, a Prolog list term with a certain structure may be reified, by convention, as a map in Java.
Type solvers provide a mechanism for telling JPC what is the best target type in a conversion operation.
The code below shows an extract of a type solver.
Note that type solvers implements the <code>TypeSolver</code> interface.
In this example, the type solver returns a <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Map.html" title="Map class"><code>Map</code></a> class on line 12 if it can conclude that the term looks like a map.
If it is unable to assign a type to the term it signals it throwing a <code>UnrecognizedObjectException</code> exception (line 14).
</p>





<p><pre data-editor="java" data-show-gutter="true">
public class MapTypeSolver implements TypeSolver&lt;Compound&gt; {
	@Override public Type getType(Compound term) {
		if(term.isList()) {
			ListTerm list = term.asList();
			Predicate&lt;Term&gt; isMapEntry = new Predicate&lt;Term&gt;() {
				@Override
				public boolean apply(Term term) {
					return isMapEntry(term);
				}
			};
			if(!list.isEmpty() &amp;&amp; Iterables.all(list, isMapEntry))
				return Map.class;
		}
		throw new UnrecognizedObjectException();
	}

	private boolean isMapEntry(Term term) {
		...
	}
}</pre></p>




<h3 id="implementingFactories">Implementing Factories</h3> 

<p>
If a converter does not know how to instantiate a conversion target type (e.g., it is abstract), it can ask the <a href="/javadocs/org/jpc/Jpc.html" title="Jpc class"><code>Jpc</code></a> context for an instance of such type.
For example, in listing \ref{lst:mapTypeSolver}  we show that a Prolog list with a certain structure will be identified by the type solver as a <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Map.html" title="Map class"><code>Map</code></a>. But the type solver does not provide any mechanism to instantiate such an interface, since its only responsibility is to give a hint on the appropriate conversion type.
Assuming that a registered factory can instantiate Java maps (listing \ref{lst:mapFactory}), a converter only needs to invoke the \lstinline{instantiate(Map.class)} in a <a href="/javadocs/org/jpc/Jpc.html" title="Jpc class"><code>Jpc</code></a> context to obtain an instance of the desired type.
An example of this factory is showed below.
</p>


<p><pre data-editor="java" data-show-gutter="true">
public class MapFactory implements Factory&lt;Map&lt;?,?&gt;&gt;() {
	@Override
	public Map&lt;?,?&gt; instantiate(Type type) {
		return new HashMap&lt;&gt;();
	}
}</pre></p>






<!-- 



JPC comes with a predefined catalog of converters that support a considerable number of common conversions, to minimise the amount of code to be written when defining new conversions.
In the rest of this section we overview both pre-defined and custom conversions.


\subsection{Primitives Conversions}

In this section we illustrate how to convert between Java and Prolog primitives. In order to facilitate the discussion, we consider a Java \lstinline{String} also as a primitive, since it is the natural equivalent of the \lstinline{atom} primitive Prolog type.

The simplest way to use our library is by means of the \lstinline{toTerm(Object)} and \lstinline{fromTerm(Term)} methods in the \lstinline{Jpc} class (introduced in section \ref{conversionContextArchitecture}).
Listing \ref{lst:toTerm} shows a list of successful assertions that illustrates some pre-defined conversions of Java types to Prolog terms. 

\begin{lstlisting}[language=Java, rulesepcolor=\color{gray}, numbers=left, numberstyle=\tiny\color{blue}, breaklines=true, breakatwhitespace=true, caption=Primitives conversions from Java to Prolog, label=lst:toTerm]
assertEquals(new Atom("true"),   jpc.toTerm(true));   //Boolean to Atom
assertEquals(new Atom("c"),      jpc.toTerm('c'));    //Character to Atom
assertEquals(new Atom("1"),      jpc.toTerm("1"));    //String to Atom
assertEquals(new IntegerTerm(1), jpc.toTerm(1));      //Integer to IntegerTerm
assertEquals(new FloatTerm(1),   jpc.toTerm(1D));     //Double to FloatTerm
\end{lstlisting}

Pre-defined conversions of Prolog terms to Java types are shown in listing \ref{lst:fromTerm}.

\begin{lstlisting}[language=Java, rulesepcolor=\color{gray}, numbers=left, numberstyle=\tiny\color{blue}, breaklines=true, breakatwhitespace=true, caption=Primitives conversions from Prolog to Java, label=lst:fromTerm]
assertEquals(true, jpc.fromTerm(new Atom("true")));   //Atom to Boolean
assertEquals("c",  jpc.fromTerm(new Atom("c")));      //Atom to String
assertEquals("1",  jpc.fromTerm(new Atom("1")));      //Atom to String
assertEquals(1L,   jpc.fromTerm(new IntegerTerm(1))); //IntegerTerm to Long
assertEquals(1D,   jpc.fromTerm(new FloatTerm(1)));   //FloatTerm to Double
\end{lstlisting}

Note that, $f$ being our default conversion function from a Java object to a Prolog term, and $g$ our default reverse conversion function, it is not always the case that $g (f(x)) = x$, where $x$ is a Java primitive object. This is because there are more primitive types in Java than in Prolog. Thus, distinct Java objects may be mapped to the same Prolog term.
For example, line 2 of listing \ref{lst:toTerm} shows that the default conversion of the Java character \lstinline{c} is the Prolog atom \lstinline{c}. However, the default conversion of the atom \lstinline{c} is the String \lstinline{"c"}.
Unfortunately, this is not necessarily always what the programmer expects.
%
The next section describes how to give hints to our library regarding the appropriate conversion that should be applied.

\subsection{Typed Conversions}

The \lstinline{Jpc} class conversion methods can receive as a second parameter the expected type of the converted object.
Listing \ref{lst:toTermTyped} shows examples of Java--Prolog conversions that specify the expected Prolog term type.
In line 1, the \lstinline{Integer} 1 is converted to an \lstinline{Atom} instead of an \lstinline{IntegerTerm} (as in listing \ref{lst:toTerm}, line 4). This is because we specify the \lstinline{Atom} class as the target conversion type.
In line 2, the \lstinline{String "1"} is converted to an  \lstinline{IntegerTerm}. 
%In this case, we specify the expected type as the \lstinline{IntegerTerm} class.


\begin{lstlisting}[language=Java, rulesepcolor=\color{gray}, numbers=left, numberstyle=\tiny\color{blue}, breaklines=true, breakatwhitespace=true, caption=Typed primitives conversions from Java to Prolog, label=lst:toTermTyped]
assertEquals(new Atom("1"), jpc.toTerm(1, Atom.class));               //Integer to Atom
assertEquals(new IntegerTerm(1), jpc.toTerm("1", IntegerTerm.class)); //String to IntegerTerm
\end{lstlisting}

In a similar way, listing \ref{lst:fromTermTyped} shows examples of Prolog--Java conversions that specify the expected Java type.

\begin{lstlisting}[language=Java, rulesepcolor=\color{gray}, numbers=left, numberstyle=\tiny\color{blue}, showspaces=false, showstringspaces=false, breaklines=true, breakatwhitespace=true, caption=Typed primitives conversions from Prolog to Java, label=lst:fromTermTyped]
assertEquals(1, jpc.fromTerm(new Atom("1"), Integer.class));         //Atom to Integer
assertEquals("1", jpc.fromTerm(new IntegerTerm(1), String.class));   //IntegerTerm to String
assertEquals("true", jpc.fromTerm(new Atom("true"), String.class));  //Atom to String
assertEquals('c', jpc.fromTerm(new Atom("c"), Character.class));     //Atom to Character
\end{lstlisting}


\subsection{Multi-Valued Conversions}

The default Jpc catalog of converters also provides conversions for multi-valued data types such as arrays, collections, and maps. Listing \ref{lst:arrayToTerm} shows a conversion of an array object with a string and an integer element: \lstinline{["apple", 10]}.
Its result is a Prolog term list having as elements an atom and an integer term: \lstinline{[apple, 10]}.
Alternatively, we could have used a list instead of an array. We would have obtained exactly the same result by replacing line 1 by:
\lstinline{Term term = jpc.toTerm(asList("apple", 10));} 

\begin{lstlisting}[language=Java, rulesepcolor=\color{gray}, numbers=left, numberstyle=\tiny\color{blue}, breaklines=true, breakatwhitespace=true, caption=Conversion of an array to a Prolog term, label=lst:arrayToTerm]
Term term = jpc.toTerm(new Object[]{"apple", 10});
assertEquals(
new Compound(".", asList(new Atom("apple"),  // equivalent to .(apple, .(10, []))
	new Compound(".", asList(new IntegerTerm(10), 
	new Atom("[]"))))), 
term);
\end{lstlisting}		

A slightly more complex example is illustrated in listing \ref{lst:mapToTerm}. First, a Java map is instantiated (lines 1--5).
The default term conversion is applied on line 6, generating a Prolog list with two key-value pairs: \lstinline{[apple:10, orange:20]}. This result is tested on lines 8--9.

\begin{lstlisting}[language=Java, rulesepcolor=\color{gray}, numbers=left, numberstyle=\tiny\color{blue}, breaklines=true, breakatwhitespace=true, caption=Conversion of a map to a Prolog term, label=lst:mapToTerm]
Map<String, Integer> map = new LinkedHashMap<String, Integer>() {{
	// LinkedHashMap preserves insertion order
	put("apple", 10);
	put("orange", 20);
}};
Term term = jpc.toTerm(map);
List<Term> listTerm = term.asList();  // converts a Prolog list term to a list of terms
assertEquals(new Compound(":", asList(new Atom("apple"), new IntegerTerm(10))), listTerm.get(0));
assertEquals(new Compound(":", asList(new Atom("orange"), new IntegerTerm(20))), listTerm.get(1));
\end{lstlisting}	
	


\subsection{Generic Types Support}

Our library provides extensive support for generic types. 
Consider the example in listing \ref{lst:redundantGenericsConversion}.
A Prolog list term is created on line 1. We use a utility class (from Google's Guava library) to obtain an instance of the parameterised type \lstinline{List<String>} (line 2).
Then we give this type as a hint to the converter (line 3) and we verify on lines 4 and 5 that the elements of the Java \lstinline{List} are indeed instances of \lstinline{String}, as it was specified on line 3.

\begin{lstlisting}[language=Java, rulesepcolor=\color{gray}, numbers=left, numberstyle=\tiny\color{blue}, breakatwhitespace=true, caption=Specifying redundantly the target parameterised type in a conversion, label=lst:redundantGenericsConversion]
Term listTerm = listTerm(new Atom("1"), new Atom("2"));
Type type = new TypeToken<List<String>>(){}.getType();
List<String> list = jpc.fromTerm(listTerm, type);
assertEquals("1", list.get(0));
assertEquals("2", list.get(1));
\end{lstlisting}	

In the previous example, the type passed to the converter was redundant, since elements in the Prolog list are atoms, which are converted by default to instances of \lstinline{String} in Java. 
Consider, however, listing \ref{lst:genericsConversion}. The main change w.r.t. the previous example is that the type we send as a hint is now \lstinline{List<Integer>} (line 3).
This instructs the converter to instantiate a list where all its elements are integers, as demonstrated on lines 4 and 5.

\begin{lstlisting}[language=Java, rulesepcolor=\color{gray}, numbers=left, numberstyle=\tiny\color{blue}, breaklines=true, breakatwhitespace=true, caption=Changing the behaviour of the converter with a parameterised type, label=lst:genericsConversion]
Term listTerm = listTerm(new Atom("1"), new Atom("2"));
Type type = new TypeToken<List<Integer>>(){}.getType();
List<Integer> list = jpc.fromTerm(listTerm, type); 
assertEquals(1, list.get(0));
assertEquals(2, list.get(1));
\end{lstlisting}	



\subsection{Inference of Conversion Target Types}
\label{typeInferenceExample}

Listing \ref{lst:mapTypeSolver} showed the implementation of a default type solver responsible of determining if the best conversion type of a term is an instance of \lstinline{Map}.
Listing \ref{lst:termToMap} shows a conversion example that relies on such type solver. On line 3 we create a list term from two previously created compound terms.
We convert it to a Java map on line 4 and test its values on lines 5 and 6.
As expected, our library infers that the best Java type of the term should be a \lstinline{Map}.
This is because the type solver finds that all the elements in the Prolog list (\lstinline{[apple-10, orange,20]}) are compounds with an arity of 2 and with functor `\lstinline{-}', which are mapped by default to map entries (i.e., instances of the \lstinline{Map.Entry} class).

\begin{lstlisting}[language=Java, rulesepcolor=\color{gray}, numbers=left, numberstyle=\tiny\color{blue}, breaklines=true, breakatwhitespace=true, caption=Conversion of a Prolog term to a map, label=lst:termToMap]
Compound c1 = new Compound("-", asList(new Atom("apple"), new IntegerTerm(10)));
Compound c2 = new Compound("-", asList(new Atom("orange"), new IntegerTerm(20)));
Term listTerm = listTerm(c1, c2); // creates a list term from a list of terms
Map map = jpc.fromTerm(listTerm);
assertEquals(10L, map.get("apple"));
assertEquals(20L, map.get("orange"));
\end{lstlisting}	

Alternatively, line 4 could be replaced by \lstinline{List list = jpc.fromTerm(listTerm, List.class);} This type hint explicitly given by the programmer has higher priority that the one inferred by the type solver. 
In this case, the result would therefore be a list of map entries since the Prolog list would be converted to a Java list (i.e., an instance of a class implementing \lstinline{List}), but the default conversion of each term in the list 
%(a compound with arity 2 and functor `\lstinline{-}') 
would still be a map entry object.

Note that we leave to the programmer the responsibility of providing enough information (i.e., a target type) in case where ambiguities are possible. 
For example, the previous type solver may answer false negatives if it cannot conclude something from the structure of members in the list (i.e., the list term is empty).
If the programmer always specify the intended conversion type the possible ambiguity disappears.



\subsection{Custom Conversions}
\label{customConversions}

The previous examples employed only predefined converters.
Using a custom conversion context as defined in listing \ref{lst:jpcBuilder}, we revisit the \lstinline{Station} class shown in listing \ref{lst:stationJpl}.
Listing \ref{lst:stationJpc} shows a new implementation of such class.
Using our library, the \lstinline{connected(Line)} method was reduced from 14 to 7 lines of code.
In addition, the methods \lstinline{asTerm()} and \lstinline{create(Term)} are not in the \lstinline{Station} class anymore since they have been encapsulated into a converter class.
Note that terms are easily created according to a conversion context. In line 5, the last argument of the compound is an instance of \lstinline{Line}. The conversion of this object to a term is done automatically by our framework. Conversely, in listing \ref{lst:stationJpl} (line 17), we were forced to invoke an explicit conversion when we requested the term representation of the line object.
The same applies in line 6, where the \lstinline{Station} instance denoted by the \lstinline{this} keyword is automatically transformed to its term representation.

A \lstinline{Query} object is instantiated on line 7 from an object abstracting a Prolog engine. %(as briefly discussed in section \ref{architecture}). 
Note that this object may (optionally) receive a context.
The advantage of making a query instance aware of a conversion context becomes clear on line 8.
To better understand this, recall from section \ref{prologVMAbstraction} that a Prolog solution is represented as a map binding variable names to terms. On line 8, the invocation of the \lstinline{selectObject(String)} method encapsulates the original query in an adapter, where each solution of this query adapter is an object whose term representation is given in the argument of \lstinline{selectObject}, taking into account the bindings of any variables in the solution.
In our example, the solution object is expressed as the Prolog variable \lstinline{Station}, which has been bound to a term representing an instance of \lstinline{Station}. The conversion of this term to a \lstinline{Station} object is transparently accomplished by our library.

\begin{lstlisting}[language=Java, rulesepcolor=\color{gray}, numbers=left, numberstyle=\tiny\color{blue}, breaklines=true, breakatwhitespace=true, caption=A Java class interacting with Prolog by means of our library, label=lst:stationJpc]
public class Station {
	...
	public Station connected(Line line) {
		String stationVarName = "Station";
		Term message = jpcContext.compound("connected", asList(new Var(stationVarName), line));
		Term objectMessage = jpcContext.compound("::", asList(this, message));
		Query query = getPrologEngine().query(objectMessage, jpcContext);
		return query.<Station>selectObject(stationVarName).oneSolution();
	}
}
\end{lstlisting}

The previous example makes use of a deterministic query. % by means of the \lstinline{oneSolution()} method. 
The \lstinline{Query} class (and query adapters) interface also supports non-deterministic queries (i.e., backtracking over solutions).
Internally, this relies on the concrete implementation of the chosen JPC driver. As already mentioned in section \ref{prologVMAbstraction}, this discussion has been left out of the scope of this work.


\subsection{Term-Quantified Converters}
\label{termQuantifiedConverterExample}

In section \ref{termQuantifiedConverters} we discussed that the domain of Prolog to Java artefact converters is, in some cases, better quantified using terms.
Listing \ref{lst:helloWorldConverter} shows a straightforward implementation of the \lstinline{HelloConverter} mentioned in that section: it returns a Java \lstinline{String} containing the name of the compound to convert, a white space, and the compound first argument (line 3).

\begin{lstlisting}[language=Java, rulesepcolor=\color{gray}, numbers=left, numberstyle=\tiny\color{blue}, breaklines=true, breakatwhitespace=true, caption=The \emph{Hello World} Converter, label=lst:helloWorldConverter]
class HelloConverter implements FromTermConverter<Compound, String> {
	@Override public String fromTerm(Compound term, Type targetType, Jpc context) {
		return ((Atom)term.getName()).getName() + " " + ((Atom)term.arg(1)).getName();
	}
}
\end{lstlisting}

Listing \ref{lst:termQuantifiedConverter} shows a concrete example of the registration and usage of this converter.
In line 3, we make use of the \lstinline{JpcBuilder} class to register the \lstinline{HelloConverter} converter.
Note that we pass both an instance of the converter and the term quantifying its domain (\lstinline{hello(_)}).
This is internally translated to an assert in the embedded JPC Prolog database, where the \lstinline{HelloConverter} converter is associated to a domain term with functor \lstinline{hello/1}.
In line 6 we verify that the result of converting the compound term \lstinline{hello(world)} is the Java \lstinline{String} ``\lstinline{hello world}'', as specified by the domain quantified converter.


\begin{lstlisting}[language=Java, rulesepcolor=\color{gray}, numbers=left, numberstyle=\tiny\color{blue}, breaklines=true, breakatwhitespace=true, caption=Applying a Term-Quantified Converter, label=lst:termQuantifiedConverter]
JpcBuilder builder = JpcBuilder.create();
Compound helloCompound = new Compound("hello",  asList(Var.ANONYMOUS_VAR));
builder.register(new HelloConverter(), helloCompound);
Jpc jpc = builder.build();
Compound helloWorldCompound = new Compound("hello",  asList(new Atom("world")));
assertEquals("hello world", jpc.fromTerm(helloWorldCompound));
\end{lstlisting}




-->


<h2 id="lowLevelAPI">The Querying API</h2> 


<h3 id="lowLevelAPI">The Low-Level Querying API</h3> 

<p>
All the JPC methods that deal explicitly with Prolog terms are part of the low-level API.
</p>


<h3 id="highLevelAPI">The High-Level Querying API</h3> 

<p>
Methods that abstract from the term representation of arbitrary Java objects are part of the JPC high-level API.
</p>

<h2>Exception Management</h2> 



<h2>Reference Management</h2> 



</div> <!-- end of content -->

    

</body>
</html>
